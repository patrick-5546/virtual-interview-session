{"ast":null,"code":"import { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty';\nimport _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty'; // Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\n\nfunction createElement(name) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const element = document.createElement(name);\n\n  for (const [name, value] of Object.entries(props)) {\n    if (name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  for (const child of Array.isArray(children) ? children : [children]) {\n    element.append(child);\n  }\n\n  return element;\n}\n/**\n * Shared options for embedding\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createChart}.\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createDashboard}.\n */\n//TODO find a way to reuse types defined in \"packages/charts-frontend/src/utils/chart/events/event-payload-types.ts\"\n\n\nlet THEME_ENUM;\n\n(function (THEME_ENUM) {\n  THEME_ENUM[\"DARK\"] = \"dark\";\n  THEME_ENUM[\"LIGHT\"] = \"light\";\n})(THEME_ENUM || (THEME_ENUM = {}));\n\nlet SCALING_ENUM;\n\n(function (SCALING_ENUM) {\n  SCALING_ENUM[\"FIXED\"] = \"fixed\";\n  SCALING_ENUM[\"SCALE\"] = \"scale\";\n})(SCALING_ENUM || (SCALING_ENUM = {}));\n/**\n * Retrieve embed options that are shared.\n *\n * Validates the values passed in as well.\n */\n\n\nconst getSharedEmbedOptions = options => {\n  const {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  } = options;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  return {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  };\n};\n\nconst getPathname = (url, pathname) => {\n  return [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', // Add trailing slash if not there\n  pathname].join('');\n};\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\n\n\nconst getChartUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/charts');\n    url.search = `id=${options.chartId}&sdk=2`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autorefresh=false`;\n    } else if (options.autoRefresh === undefined) {\n      url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.filter) {\n      url.search += `&filter=${encodeURIComponent(EJSON.stringify(options.filter, {\n        relaxed: false\n      }))}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/**\n * Constructs the dashboard iframe URL from the baseUrl, dashboardId & tenantId\n */\n\n\nconst getDashboardUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/dashboards');\n    url.search = `id=${options.dashboardId}&sdk=1`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autoRefresh=false`;\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.showTitleAndDesc === true) {\n      url.search += `&showTitleAndDesc=true`;\n    }\n\n    if (options.widthMode) {\n      url.search += `&scalingWidth=${options.widthMode}`;\n    }\n\n    if (options.heightMode) {\n      url.search += `&scalingHeight=${options.heightMode}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.chartsBackground) {\n      url.search += `&chartsBackground=${options.chartsBackground}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/*\n  Parses a CSS Measurement from an unknown value\n  - if it's a string, we trust that it is well-formed\n  - if it's a number, we assume the units are pixels\n  - otherwise we return null\n*/\n\n\nconst parseCSSMeasurement = value => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return `${value}px`;\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\n\nconst getBackground = (background, theme, lightBackground, darkBackground) => {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return darkBackground;\n  return lightBackground;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseEmbedItem {\n  constructor() {\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ERRORS\", void 0);\n\n    _defineProperty(this, \"COLOUR\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n  }\n  /**\n   * Renders an embeddable item into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the item has successfully been embedded\n   */\n\n\n  async render(container) {\n    if (this.iframe) {\n      throw new Error(this.ERRORS.IFRAME);\n    } // Create styled container\n\n\n    const embedRoot = this._configureEmbedRoot(createElement('div', {\n      style: {\n        position: 'relative',\n        overflow: 'hidden',\n        minHeight: Boolean(this.options.height) ? 0 : '15px',\n        width: parseCSSMeasurement(this.options.width) || '100%',\n        height: parseCSSMeasurement(this.options.height) || '100%'\n      }\n    })); // Create host\n\n\n    const host = this._configureHost(Chatty.createHost(this.getEmbedUrl()).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot)).build(); // Customise IFrame styles\n\n\n    host.iframe.setAttribute('aria-label', this.name);\n    Object.assign(host.iframe.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      border: 0,\n      width: '100%',\n      height: '100%'\n    }); // Remove any existing nodes in our target container\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    container.appendChild(embedRoot); // connect to iframe\n\n    this.connection = await host.connect();\n    this.iframe = host.iframe;\n\n    this._setBackground(this.options.background, this.options.theme); // configure token if needed\n\n\n    await this._retrieveAndSetToken(); // Ready to actually render Embedded Item\n\n    await this._send('ready');\n  }\n  /**\n   * @returns whether auto refreshing is enabled\n   */\n\n\n  async isAutoRefresh() {\n    const [result] = await this._send('get', 'autoRefresh'); // autoRefresh from embed chart may be a number when refreshInterval is set\n\n    return typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable auto refreshing.\n   */\n\n\n  async setAutoRefresh(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('autoRefresh property value should be a boolean');\n    }\n\n    await this._send('set', 'autoRefresh', value);\n  }\n  /**\n   * @returns the number of seconds before a chart or dashboard's data expires\n   */\n\n\n  async getMaxDataAge() {\n    const [result] = await this._send('get', 'maxDataAge');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart or dashboard's data expires.\n   */\n\n\n  async setMaxDataAge(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('maxDataAge property value should be a number');\n    }\n\n    await this._send('set', 'maxDataAge', value);\n  }\n  /**\n   * Sets the color scheme to apply to the chart or dashboard.\n   *\n   * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n   */\n\n\n  async setTheme(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('theme property value should be a string');\n    } // if invalid theme string is provided, default it to light\n\n\n    const newTheme = Object.values(THEME_ENUM).includes(value) ? value : THEME_ENUM.LIGHT;\n    await this._send('set', 'theme', newTheme);\n\n    this._setBackground(this.options.background, newTheme);\n  }\n  /**\n   * @returns the current theme applied to the chart or dashboard\n   */\n\n\n  async getTheme() {\n    const [result] = await this._send('get', 'theme');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n  _configureHost(hostBuilder) {\n    return hostBuilder.on('refreshToken', () => this._retrieveAndSetToken());\n  }\n\n  _configureEmbedRoot(embedRoot) {\n    return embedRoot;\n  }\n\n  _setBackground(background, theme) {\n    this.iframe.style.backgroundColor = getBackground(background, theme, this.COLOUR.LIGHT, this.COLOUR.DARK);\n  }\n\n  async _retrieveAndSetToken() {\n    if (this.options.getUserToken) {\n      const token = await this.options.getUserToken();\n      await this._send('set', 'token', token);\n    }\n  }\n  /**\n   * Send message to embedded app.\n   */\n\n\n  _send(eventName) {\n    if (this.connection) {\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n\n      return this.connection.sendAndReceive(eventName, ...payload);\n    }\n\n    return Promise.reject(this.ERRORS.SEND);\n  }\n\n}\n\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nlet eventHandlerIndex = Date.now();\n\nfunction EventSource(Sender) {\n  var _temp;\n\n  return _temp = class extends Sender {\n    constructor() {\n      super(...arguments);\n\n      _defineProperty$1(this, \"_eventHandlers\", {\n        click: {} // refresh: {} To be added soon\n\n      });\n    }\n    /**\n     * Handle the event sent from embedded app.\n     */\n\n\n    _handleEvent(event, payload, handlerIds) {\n      const handlers = this._eventHandlers[event];\n\n      for (const id of handlerIds) {\n        try {\n          var _handlers$id; // since communication between host and SDK is async,\n          // it's possible that some handlers have been removed;\n          // thus needs to check if handler still exists before calling\n\n\n          (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n        } catch (error) {\n          console.warn(`Error calling handler for event [${event}]: ${error}`);\n        }\n      }\n    }\n    /**\n     * Sets an event listener\n     * @param event - the event you are subscribing to\n     * @param eventHandler - the callback to be executed when the event is triggered\n     * @param options - optional options object, can be used to customise when handler is called\n     */\n\n\n    addEventListener(event, eventHandler, options) {\n      var _h$options$includes;\n\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n\n      if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(f => _isEmpty(f))) {\n        // eslint-disable-next-line no-console\n        console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n      } // ignore if same handler and options have been added already\n\n\n      if (!Object.keys(handlers).some(id => _isEqual(handlers[id], h))) {\n        const handlerId = (++eventHandlerIndex).toString(36);\n        handlers[handlerId] = h;\n        return this._send('eventHandler', event, {\n          handlerId,\n          options: h.options\n        });\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Removes an event listener\n     * @param event - the event you are unsubscribing from\n     * @param eventHandler - the event listener function you are unsubscribing from\n     * @param options - optional options object used when addEventListener\n     */\n\n\n    removeEventListener(event, eventHandler, options) {\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n      const handlerId = Object.keys(handlers).find(id => _isEqual(handlers[id], h));\n\n      if (handlerId) {\n        delete handlers[handlerId];\n        return this._send('eventHandler', event, {\n          handlerId\n        });\n      }\n\n      return Promise.resolve();\n    }\n\n  }, _temp;\n}\n\nfunction Refreshable(Sender) {\n  return class extends Sender {\n    /**\n     * Triggers a refresh of the chart or dashboard (if it has been embedded).\n     *\n     * @returns a promise that resolves once the chart or dashboard updated its data\n     */\n    async refresh() {\n      await this._send('refresh');\n    }\n\n  };\n}\n\nfunction _defineProperty$2(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst getChartOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    chartId,\n    filter,\n    refreshInterval\n  } = options; // Verify chart embed options\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    chartId,\n    filter,\n    refreshInterval\n  };\n};\n\nclass ChartEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$2(this, \"name\", 'Embedded Chart');\n\n    _defineProperty$2(this, \"ERRORS\", {\n      SEND: 'Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.',\n      IFRAME: 'A chart can only be rendered into a container once'\n    });\n\n    _defineProperty$2(this, \"COLOUR\", {\n      LIGHT: '#FFFFFF',\n      DARK: '#21313C'\n    });\n\n    _defineProperty$2(this, \"options\", void 0);\n\n    this.options = getChartOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getChartUrl(this.options);\n  }\n\n}\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\n\nclass Chart extends Refreshable(EventSource(ChartEventSender)) {\n  /**\n   * @returns the number of seconds a chart will wait before refreshing\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n  async getRefreshInterval() {\n    const [result] = await this._send('get', 'autorefresh');\n    console.warn(\"The 'getRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart will wait before refreshing.\n   *\n   * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n\n\n  async setRefreshInterval(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('refreshInterval property value should be a number');\n    }\n\n    console.warn(\"The 'setRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the current filter applied to the embedded chart.\n   */\n\n\n  async getFilter() {\n    const [result] = await this._send('get', 'filter');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the filter to apply to the embedded chart.\n   *\n   * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n   * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n   */\n\n\n  async setFilter(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('filter property value should be an object');\n    }\n\n    await this._send('set', 'filter', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * @returns the current highlight applied to the embedded chart.\n   */\n\n\n  async getHighlight() {\n    const [result] = await this._send('get', 'highlight');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the highlight to apply to the embedded chart.\n   *\n   * This is the exact same object that can be used in 'setFilter'.\n   * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n   * @param value The highlight object to be applied to the chart\n   */\n\n\n  async setHighlight(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('highlight property value should be an object');\n    }\n\n    await this._send('set', 'highlight', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', this._handleEvent.bind(this));\n  }\n  /**\n   * @returns the data of the embedded chart.\n   */\n\n\n  async getData() {\n    const [result] = await this._send('get', 'data');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n}\n\nclass DashboardChartEventSender {\n  constructor(chartId, dashboard) {\n    this.chartId = chartId;\n    this.dashboard = dashboard;\n  }\n  /**\n   * Send message to embedded app via dashboard.\n   */\n\n\n  _send(msgName) {\n    for (var _len2 = arguments.length, payload = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      payload[_key2 - 1] = arguments[_key2];\n    }\n\n    return this.dashboard._send(msgName, ...payload, this.chartId);\n  }\n\n}\n\nclass DashboardChart extends Refreshable(EventSource(DashboardChartEventSender)) {}\n\nfunction _defineProperty$3(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst getDashboardOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  } = options; // Verify dashboard embed options\n\n  if (typeof dashboardId !== 'string' || dashboardId.length === 0) {\n    throw new Error('dashboardId must be specified');\n  }\n\n  if (chartsBackground !== undefined && typeof chartsBackground !== 'string') {\n    throw new Error('chartsBackground must be a string if specified');\n  }\n\n  if (widthMode !== undefined && typeof widthMode !== 'string') {\n    throw new Error('widthMode must be a string if specified');\n  }\n\n  if (widthMode !== undefined && widthMode !== SCALING_ENUM.FIXED && widthMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`widthMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (heightMode !== undefined && typeof heightMode !== 'string') {\n    throw new Error('heightMode must be a string if specified');\n  }\n\n  if (heightMode !== undefined && heightMode !== SCALING_ENUM.FIXED && heightMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`heightMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (showTitleAndDesc !== undefined && typeof showTitleAndDesc !== 'boolean') {\n    throw new Error('showTitleAndDesc must be a boolean value if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  };\n};\n\nclass DashboardEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$3(this, \"name\", 'Embedded Dashboard');\n\n    _defineProperty$3(this, \"ERRORS\", {\n      SEND: 'Dashboard has not been rendered. Ensure that you wait for the promise returned by `dashboard.render()` before trying to manipulate a dashboard.',\n      IFRAME: 'A dashboard can only be rendered into a container once'\n    });\n\n    _defineProperty$3(this, \"COLOUR\", {\n      LIGHT: '#F1F5F4',\n      DARK: '#12212C'\n    });\n\n    _defineProperty$3(this, \"options\", void 0);\n\n    this.options = getDashboardOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getDashboardUrl(this.options);\n  }\n\n}\n/**\n * # Dashboard\n *\n * Allows you to interact and embed dashboards into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const dashboard = sdk.createDashboard({ ... });\n *\n * // renders a dashboard\n * dashboard.render(document.getElementById('embed-dashboard'));\n *\n * ```\n */\n\n\nclass Dashboard extends Refreshable(DashboardEventSender) {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty$3(this, \"charts\", {});\n  }\n  /**\n   * @returns current chartsBackground or empty string if not set\n   */\n\n\n  async getChartsBackground() {\n    const [result] = await this._send('get', 'chartsBackground');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set a custom background color for all charts.\n   * To clear existing value, set it to empty string.\n   */\n\n\n  async setChartsBackground(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('chartsBackground property value should be a string');\n    }\n\n    await this._send('set', 'chartsBackground', value);\n  }\n  /**\n   * @returns whether attribution logo should be shown\n   */\n\n\n  async isShowAttribution() {\n    const [result] = await this._send('get', 'attribution');\n    return typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable attribution logo.\n   */\n\n\n  async setShowAttribution(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('showAttribution property value should be a boolean');\n    }\n\n    await this._send('set', 'attribution', value);\n  }\n  /**\n   * @returns get width scaling mode of embedded dashboard\n   */\n\n\n  async getWidthMode() {\n    const [result] = await this._send('get', 'scalingWidth');\n    return result === SCALING_ENUM.FIXED || result === SCALING_ENUM.SCALE ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set width scaling mode for embedded dashboard\n   */\n\n\n  async setWidthMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('widthMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingWidth', value);\n  }\n  /**\n   * @returns get height scaling mode of embedded dashboard\n   */\n\n\n  async getHeightMode() {\n    const [result] = await this._send('get', 'scalingHeight');\n    return result === 'fixed' || result === 'scale' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set height scaling mode for embedded dashboard\n   */\n\n\n  async setHeightMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('heightMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingHeight', value);\n  }\n  /**\n   * @returns get the dashboard chart with specified id\n   */\n\n\n  async getChart(id) {\n    if (!this.charts[id]) {\n      const [chartIds] = await this._send('get', 'charts', [id]);\n\n      if (!Array.isArray(chartIds)) {\n        return Promise.reject('unexpected response received from iframe');\n      }\n\n      if (chartIds.length !== 1) {\n        return Promise.reject('Invalid chart id: ' + id);\n      }\n\n      this.charts[id] = new DashboardChart(id, this);\n    }\n\n    return this.charts[id];\n  }\n  /**\n   * @returns all charts on the dashboard\n   */\n\n\n  async getAllCharts() {\n    const [chartIds] = await this._send('get', 'charts');\n\n    if (!Array.isArray(chartIds)) {\n      return Promise.reject('unexpected response received from iframe');\n    }\n\n    const charts = [];\n    chartIds.forEach(id => {\n      if (!this.charts[id]) {\n        this.charts[id] = new DashboardChart(id, this);\n      }\n\n      charts.push(this.charts[id]);\n    });\n    return charts;\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', (event, payload, handlerIds) => {\n      const chartId = payload.chartId;\n\n      this.charts[chartId]._handleEvent(event, payload, handlerIds);\n    });\n  }\n\n} // Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\n\n\nconst isJWTExpired = jwt => {\n  try {\n    const [header, payload, signature] = jwt.split('.');\n    const {\n      exp\n    } = JSON.parse(atob(payload)); // Check the current time against the expiry (minus 5 minutes) in the token\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nasync function getRealmUserToken(stitchAppClient) {\n  const client = stitchAppClient;\n\n  if (!client.auth || !client.auth.authInfo) {\n    throw new Error('Unfamiliar Stitch client version');\n  }\n\n  if (!client.auth.isLoggedIn) {\n    throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n  }\n\n  if (!client.auth.authInfo.accessToken) {\n    throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n  }\n\n  if (isJWTExpired(client.auth.authInfo.accessToken)) {\n    // Attempt to refresh token using progression from public -> private apis\n    if (client.auth.refreshCustomData) {\n      await client.auth.refreshCustomData(); // supported from 4.8.0\n    } else if (client.auth.refreshAccessToken) {\n      await client.auth.refreshAccessToken(); // supported from 4.0.0\n    } else {\n      throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n    }\n  }\n\n  return client.auth.authInfo.accessToken;\n}\n\nfunction _defineProperty$4(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Creates an instance of the embedding SDK\n */\n\n\nclass EmbedSDK {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  constructor(options) {\n    _defineProperty$4(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  createChart(options) {\n    return new Chart({ ...this.defaultOptions,\n      ...options\n    });\n  }\n  /**\n   * Creates a new {@link Dashboard} instance that allows you\n   * to embed a dashboard into your application\n   */\n\n\n  createDashboard(options) {\n    return new Dashboard({ ...this.defaultOptions,\n      ...options\n    });\n  }\n\n}\n\nexport default EmbedSDK;\nexport { getRealmUserToken };","map":{"version":3,"sources":["C:/Users/user/React/react-login/node_modules/@mongodb-js/charts-embed-dom/dist/charts-embed-dom.esm.js"],"names":["EJSON","Chatty","_isEqual","_isEmpty","createElement","name","props","children","element","document","value","Object","entries","assign","style","setAttribute","child","Array","isArray","append","THEME_ENUM","SCALING_ENUM","getSharedEmbedOptions","options","background","baseUrl","autoRefresh","maxDataAge","width","height","theme","showAttribution","getUserToken","length","Error","undefined","includes","getPathname","url","pathname","slice","join","getChartUrl","URL","search","chartId","refreshInterval","filter","encodeURIComponent","stringify","relaxed","toString","e","getDashboardUrl","dashboardId","showTitleAndDesc","widthMode","heightMode","chartsBackground","parseCSSMeasurement","getBackground","lightBackground","darkBackground","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","BaseEmbedItem","constructor","render","container","iframe","ERRORS","IFRAME","embedRoot","_configureEmbedRoot","position","overflow","minHeight","Boolean","host","_configureHost","createHost","getEmbedUrl","withSandboxAttribute","appendTo","build","top","left","border","firstChild","removeChild","appendChild","connection","connect","_setBackground","_retrieveAndSetToken","_send","isAutoRefresh","result","Promise","reject","setAutoRefresh","getMaxDataAge","setMaxDataAge","setTheme","newTheme","values","LIGHT","getTheme","hostBuilder","on","backgroundColor","COLOUR","DARK","token","eventName","payload","sendAndReceive","SEND","_defineProperty$1","eventHandlerIndex","Date","now","EventSource","Sender","_temp","click","_handleEvent","event","handlerIds","handlers","_eventHandlers","id","_handlers$id","handle","error","console","warn","addEventListener","eventHandler","_h$options$includes","h","every","f","keys","some","handlerId","resolve","removeEventListener","find","Refreshable","refresh","_defineProperty$2","getChartOptions","sharedEmbedOptions","ChartEventSender","Chart","getRefreshInterval","setRefreshInterval","getFilter","setFilter","getHighlight","setHighlight","bind","getData","DashboardChartEventSender","dashboard","msgName","DashboardChart","_defineProperty$3","getDashboardOptions","FIXED","SCALE","DashboardEventSender","Dashboard","getChartsBackground","setChartsBackground","isShowAttribution","setShowAttribution","getWidthMode","setWidthMode","getHeightMode","setHeightMode","getChart","charts","chartIds","getAllCharts","forEach","push","isJWTExpired","jwt","header","signature","split","exp","JSON","parse","atob","getRealmUserToken","stitchAppClient","client","auth","authInfo","isLoggedIn","accessToken","refreshCustomData","refreshAccessToken","_defineProperty$4","EmbedSDK","defaultOptions","createChart","createDashboard"],"mappings":"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","sourcesContent":["import { EJSON } from 'bson';\nimport { Chatty } from '@looker/chatty';\nimport _isEqual from 'lodash/isEqual';\nimport _isEmpty from 'lodash/isEmpty';\n\n// Given an object `Target`, find all property names of type `Type`\n// Given an object `Target`, filter out all properties that aren't of type `Type`\nfunction createElement(name, props = {}, children = []) {\n  const element = document.createElement(name);\n\n  for (const [name, value] of Object.entries(props)) {\n    if (name === 'style') {\n      Object.assign(element.style, props.style);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  for (const child of Array.isArray(children) ? children : [children]) {\n    element.append(child);\n  }\n\n  return element;\n}\n\n/**\n * Shared options for embedding\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createChart}.\n */\n\n/**\n * The set of options that you can use when both creating an {@link EmbedSDK} object or using {@link EmbedSDK.createDashboard}.\n */\n//TODO find a way to reuse types defined in \"packages/charts-frontend/src/utils/chart/events/event-payload-types.ts\"\nlet THEME_ENUM;\n\n(function (THEME_ENUM) {\n  THEME_ENUM[\"DARK\"] = \"dark\";\n  THEME_ENUM[\"LIGHT\"] = \"light\";\n})(THEME_ENUM || (THEME_ENUM = {}));\n\nlet SCALING_ENUM;\n\n(function (SCALING_ENUM) {\n  SCALING_ENUM[\"FIXED\"] = \"fixed\";\n  SCALING_ENUM[\"SCALE\"] = \"scale\";\n})(SCALING_ENUM || (SCALING_ENUM = {}));\n\n/**\n * Retrieve embed options that are shared.\n *\n * Validates the values passed in as well.\n */\nconst getSharedEmbedOptions = options => {\n  const {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  } = options;\n\n  if (typeof baseUrl !== 'string' || baseUrl.length === 0) {\n    throw new Error('Base URL must be a valid URL');\n  }\n\n  if (background !== undefined && typeof background !== 'string') {\n    throw new Error('background must be a string if specified');\n  }\n\n  if (autoRefresh !== undefined && typeof autoRefresh !== 'boolean') {\n    throw new Error('autoRefresh must be a boolean if specified');\n  }\n\n  if (maxDataAge !== undefined && typeof maxDataAge !== 'number') {\n    throw new Error('maxDataAge must be a number if specified');\n  }\n\n  if (width !== undefined && !['number', 'string'].includes(typeof width)) {\n    throw new Error('Width must be a string or number if specified');\n  }\n\n  if (height !== undefined && !['number', 'string'].includes(typeof height)) {\n    throw new Error('Height must be a string or number if specified');\n  }\n\n  if (theme !== undefined && typeof theme !== 'string') {\n    throw new Error('Theme must be a string if specified');\n  }\n\n  if (showAttribution !== undefined && typeof showAttribution !== 'boolean') {\n    throw new Error('Attribution must be a boolean value if specified');\n  }\n\n  if (getUserToken !== undefined && typeof getUserToken !== 'function') {\n    throw new Error('getUserToken must be a function');\n  }\n\n  return {\n    background,\n    baseUrl,\n    autoRefresh,\n    maxDataAge,\n    width,\n    height,\n    theme,\n    showAttribution,\n    getUserToken\n  };\n};\nconst getPathname = (url, pathname) => {\n  return [url.pathname, url.pathname.slice(-1) === '/' ? '' : '/', // Add trailing slash if not there\n  pathname].join('');\n};\n/**\n * Constructs the chart iframe URL from the baseUrl, chartId & tenantId\n */\n\nconst getChartUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/charts');\n    url.search = `id=${options.chartId}&sdk=2`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autorefresh=false`;\n    } else if (options.autoRefresh === undefined) {\n      url.search += options.refreshInterval ? `&autorefresh=${options.refreshInterval}` : '';\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.filter) {\n      url.search += `&filter=${encodeURIComponent(EJSON.stringify(options.filter, {\n        relaxed: false\n      }))}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/**\n * Constructs the dashboard iframe URL from the baseUrl, dashboardId & tenantId\n */\n\nconst getDashboardUrl = options => {\n  try {\n    const url = new URL(options.baseUrl);\n    url.pathname = getPathname(url, 'embed/dashboards');\n    url.search = `id=${options.dashboardId}&sdk=1`;\n\n    if (options.autoRefresh === false) {\n      url.search += `&autoRefresh=false`;\n    }\n\n    if (options.maxDataAge !== undefined) {\n      url.search += `&maxDataAge=${options.maxDataAge}`;\n    }\n\n    if (options.showTitleAndDesc === true) {\n      url.search += `&showTitleAndDesc=true`;\n    }\n\n    if (options.widthMode) {\n      url.search += `&scalingWidth=${options.widthMode}`;\n    }\n\n    if (options.heightMode) {\n      url.search += `&scalingHeight=${options.heightMode}`;\n    }\n\n    if (options.theme) {\n      url.search += `&theme=${options.theme}`;\n    }\n\n    if (options.chartsBackground) {\n      url.search += `&chartsBackground=${options.chartsBackground}`;\n    }\n\n    if (options.showAttribution === false) {\n      url.search += `&attribution=false`;\n    }\n\n    return url.toString();\n  } catch (e) {\n    throw new Error('Base URL must be a valid URL');\n  }\n};\n/*\n  Parses a CSS Measurement from an unknown value\n  - if it's a string, we trust that it is well-formed\n  - if it's a number, we assume the units are pixels\n  - otherwise we return null\n*/\n\nconst parseCSSMeasurement = value => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return `${value}px`;\n  return null;\n};\n/**\n * Returns the background after validation checks\n * or default background based on theme if not set\n */\n\nconst getBackground = (background, theme, lightBackground, darkBackground) => {\n  if (typeof background === 'string' && background.length > 0) return background;\n  if (theme === 'dark') return darkBackground;\n  return lightBackground;\n};\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass BaseEmbedItem {\n  constructor() {\n    _defineProperty(this, \"iframe\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ERRORS\", void 0);\n\n    _defineProperty(this, \"COLOUR\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n  }\n\n  /**\n   * Renders an embeddable item into the given `container`.\n   *\n   * This method should only be called once, and successive attempts to call `render`\n   * will fail with an error.\n   *\n   * @returns a promise that will resolve once the item has successfully been embedded\n   */\n  async render(container) {\n    if (this.iframe) {\n      throw new Error(this.ERRORS.IFRAME);\n    } // Create styled container\n\n\n    const embedRoot = this._configureEmbedRoot(createElement('div', {\n      style: {\n        position: 'relative',\n        overflow: 'hidden',\n        minHeight: Boolean(this.options.height) ? 0 : '15px',\n        width: parseCSSMeasurement(this.options.width) || '100%',\n        height: parseCSSMeasurement(this.options.height) || '100%'\n      }\n    })); // Create host\n\n\n    const host = this._configureHost(Chatty.createHost(this.getEmbedUrl()).withSandboxAttribute('allow-scripts').withSandboxAttribute('allow-same-origin').withSandboxAttribute('allow-popups').withSandboxAttribute('allow-popups-to-escape-sandbox').appendTo(embedRoot)).build(); // Customise IFrame styles\n\n\n    host.iframe.setAttribute('aria-label', this.name);\n    Object.assign(host.iframe.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      border: 0,\n      width: '100%',\n      height: '100%'\n    }); // Remove any existing nodes in our target container\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    container.appendChild(embedRoot); // connect to iframe\n\n    this.connection = await host.connect();\n    this.iframe = host.iframe;\n\n    this._setBackground(this.options.background, this.options.theme); // configure token if needed\n\n\n    await this._retrieveAndSetToken(); // Ready to actually render Embedded Item\n\n    await this._send('ready');\n  }\n  /**\n   * @returns whether auto refreshing is enabled\n   */\n\n\n  async isAutoRefresh() {\n    const [result] = await this._send('get', 'autoRefresh'); // autoRefresh from embed chart may be a number when refreshInterval is set\n\n    return typeof result === 'number' || typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable auto refreshing.\n   */\n\n\n  async setAutoRefresh(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('autoRefresh property value should be a boolean');\n    }\n\n    await this._send('set', 'autoRefresh', value);\n  }\n  /**\n   * @returns the number of seconds before a chart or dashboard's data expires\n   */\n\n\n  async getMaxDataAge() {\n    const [result] = await this._send('get', 'maxDataAge');\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart or dashboard's data expires.\n   */\n\n\n  async setMaxDataAge(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('maxDataAge property value should be a number');\n    }\n\n    await this._send('set', 'maxDataAge', value);\n  }\n  /**\n   * Sets the color scheme to apply to the chart or dashboard.\n   *\n   * If the theme is set to 'dark' and you have specified a custom background color, you should ensure that your background color has appropriate contrast.\n   */\n\n\n  async setTheme(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('theme property value should be a string');\n    } // if invalid theme string is provided, default it to light\n\n\n    const newTheme = Object.values(THEME_ENUM).includes(value) ? value : THEME_ENUM.LIGHT;\n    await this._send('set', 'theme', newTheme);\n\n    this._setBackground(this.options.background, newTheme);\n  }\n  /**\n   * @returns the current theme applied to the chart or dashboard\n   */\n\n\n  async getTheme() {\n    const [result] = await this._send('get', 'theme');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n  _configureHost(hostBuilder) {\n    return hostBuilder.on('refreshToken', () => this._retrieveAndSetToken());\n  }\n\n  _configureEmbedRoot(embedRoot) {\n    return embedRoot;\n  }\n\n  _setBackground(background, theme) {\n    this.iframe.style.backgroundColor = getBackground(background, theme, this.COLOUR.LIGHT, this.COLOUR.DARK);\n  }\n\n  async _retrieveAndSetToken() {\n    if (this.options.getUserToken) {\n      const token = await this.options.getUserToken();\n      await this._send('set', 'token', token);\n    }\n  }\n  /**\n   * Send message to embedded app.\n   */\n\n\n  _send(eventName, ...payload) {\n    if (this.connection) {\n      return this.connection.sendAndReceive(eventName, ...payload);\n    }\n\n    return Promise.reject(this.ERRORS.SEND);\n  }\n\n}\n\nfunction _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nlet eventHandlerIndex = Date.now();\nfunction EventSource(Sender) {\n  var _temp;\n\n  return _temp = class extends Sender {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty$1(this, \"_eventHandlers\", {\n        click: {} // refresh: {} To be added soon\n\n      });\n    }\n\n    /**\n     * Handle the event sent from embedded app.\n     */\n    _handleEvent(event, payload, handlerIds) {\n      const handlers = this._eventHandlers[event];\n\n      for (const id of handlerIds) {\n        try {\n          var _handlers$id;\n\n          // since communication between host and SDK is async,\n          // it's possible that some handlers have been removed;\n          // thus needs to check if handler still exists before calling\n          (_handlers$id = handlers[id]) === null || _handlers$id === void 0 ? void 0 : _handlers$id.handle(payload);\n        } catch (error) {\n          console.warn(`Error calling handler for event [${event}]: ${error}`);\n        }\n      }\n    }\n    /**\n     * Sets an event listener\n     * @param event - the event you are subscribing to\n     * @param eventHandler - the callback to be executed when the event is triggered\n     * @param options - optional options object, can be used to customise when handler is called\n     */\n\n\n    addEventListener(event, eventHandler, options) {\n      var _h$options$includes;\n\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n\n      if ((_h$options$includes = h.options.includes) !== null && _h$options$includes !== void 0 && _h$options$includes.every(f => _isEmpty(f))) {\n        // eslint-disable-next-line no-console\n        console.warn('Empty includes filters out all events. Event handler will never be called. Is this intended?');\n      } // ignore if same handler and options have been added already\n\n\n      if (!Object.keys(handlers).some(id => _isEqual(handlers[id], h))) {\n        const handlerId = (++eventHandlerIndex).toString(36);\n        handlers[handlerId] = h;\n        return this._send('eventHandler', event, {\n          handlerId,\n          options: h.options\n        });\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Removes an event listener\n     * @param event - the event you are unsubscribing from\n     * @param eventHandler - the event listener function you are unsubscribing from\n     * @param options - optional options object used when addEventListener\n     */\n\n\n    removeEventListener(event, eventHandler, options) {\n      const handlers = this._eventHandlers[event];\n\n      if (!handlers) {\n        throw new Error(`Not supported event: ${event}`);\n      }\n\n      const h = {\n        handle: eventHandler,\n        options: {\n          includes: options === null || options === void 0 ? void 0 : options.includes\n        }\n      };\n      const handlerId = Object.keys(handlers).find(id => _isEqual(handlers[id], h));\n\n      if (handlerId) {\n        delete handlers[handlerId];\n        return this._send('eventHandler', event, {\n          handlerId\n        });\n      }\n\n      return Promise.resolve();\n    }\n\n  }, _temp;\n}\n\nfunction Refreshable(Sender) {\n  return class extends Sender {\n    /**\n     * Triggers a refresh of the chart or dashboard (if it has been embedded).\n     *\n     * @returns a promise that resolves once the chart or dashboard updated its data\n     */\n    async refresh() {\n      await this._send('refresh');\n    }\n\n  };\n}\n\nfunction _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst getChartOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    chartId,\n    filter,\n    refreshInterval\n  } = options; // Verify chart embed options\n\n  if (typeof chartId !== 'string' || chartId.length === 0) {\n    throw new Error('Chart ID must be specified');\n  }\n\n  if (filter !== undefined && (!filter || typeof filter !== 'object')) {\n    throw new Error('Filter must be an object if specified');\n  }\n\n  if (refreshInterval !== undefined && typeof refreshInterval !== 'number') {\n    throw new Error('refreshInterval interval must be a number if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    chartId,\n    filter,\n    refreshInterval\n  };\n};\n\nclass ChartEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$2(this, \"name\", 'Embedded Chart');\n\n    _defineProperty$2(this, \"ERRORS\", {\n      SEND: 'Chart has not been rendered. Ensure that you wait for the promise returned by `chart.render()` before trying to manipulate a chart.',\n      IFRAME: 'A chart can only be rendered into a container once'\n    });\n\n    _defineProperty$2(this, \"COLOUR\", {\n      LIGHT: '#FFFFFF',\n      DARK: '#21313C'\n    });\n\n    _defineProperty$2(this, \"options\", void 0);\n\n    this.options = getChartOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getChartUrl(this.options);\n  }\n\n}\n/**\n * # Chart\n *\n * Allows you to interact and embed charts into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const chart = sdk.createChart({ ... });\n *\n * // renders a chart\n * chart.render(document.getElementById('embed-chart'));\n *\n * // dynamically set a filter\n * chart.setFilter({ age: { $gt: 50 } });\n * ```\n */\n\n\nclass Chart extends Refreshable(EventSource(ChartEventSender)) {\n  /**\n   * @returns the number of seconds a chart will wait before refreshing\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n  async getRefreshInterval() {\n    const [result] = await this._send('get', 'autorefresh');\n    console.warn(\"The 'getRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    return typeof result === 'number' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set the number of seconds a chart will wait before refreshing.\n   *\n   * The minimum refresh interval is 10 seconds. To disable, set the refresh interval to 0.\n   * @deprecated This method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\n   */\n\n\n  async setRefreshInterval(value) {\n    if (typeof value !== 'number') {\n      return Promise.reject('refreshInterval property value should be a number');\n    }\n\n    console.warn(\"The 'setRefreshInterval' method is deprecated. Please use the 'autoRefresh' option with the 'maxDataAge' option to configure how often the chart refreshes.\");\n    await this._send('set', 'autorefresh', value);\n  }\n  /**\n   * @returns the current filter applied to the embedded chart.\n   */\n\n\n  async getFilter() {\n    const [result] = await this._send('get', 'filter');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the filter to apply to the embedded chart.\n   *\n   * This expects an object that contains a valid [query operators](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors).\n   * Any fields referenced in this filter are expected to be whitelisted in the \"Embed Chart\" dialog for each Chart you wish to filter on.\n   */\n\n\n  async setFilter(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('filter property value should be an object');\n    }\n\n    await this._send('set', 'filter', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n  /**\n   * @returns the current highlight applied to the embedded chart.\n   */\n\n\n  async getHighlight() {\n    const [result] = await this._send('get', 'highlight');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Sets the highlight to apply to the embedded chart.\n   *\n   * This is the exact same object that can be used in 'setFilter'.\n   * However, it [doesn't support some query expressions](https://docs.mongodb.com/charts/saas/embedded-chart-options/)\n   * @param value The highlight object to be applied to the chart\n   */\n\n\n  async setHighlight(value) {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return Promise.reject('highlight property value should be an object');\n    }\n\n    await this._send('set', 'highlight', EJSON.stringify(value, {\n      relaxed: false\n    }));\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', this._handleEvent.bind(this));\n  }\n  /**\n   * @returns the data of the embedded chart.\n   */\n\n\n  async getData() {\n    const [result] = await this._send('get', 'data');\n    return typeof result === 'object' && result !== null ? result : Promise.reject('unexpected response received from iframe');\n  }\n\n}\n\nclass DashboardChartEventSender {\n  constructor(chartId, dashboard) {\n    this.chartId = chartId;\n    this.dashboard = dashboard;\n  }\n  /**\n   * Send message to embedded app via dashboard.\n   */\n\n\n  _send(msgName, ...payload) {\n    return this.dashboard._send(msgName, ...payload, this.chartId);\n  }\n\n}\n\nclass DashboardChart extends Refreshable(EventSource(DashboardChartEventSender)) {}\n\nfunction _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst getDashboardOptions = options => {\n  if (typeof options !== 'object' || options === null) {\n    throw new Error('Options argument must be an object');\n  }\n\n  const sharedEmbedOptions = getSharedEmbedOptions(options);\n  const {\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  } = options; // Verify dashboard embed options\n\n  if (typeof dashboardId !== 'string' || dashboardId.length === 0) {\n    throw new Error('dashboardId must be specified');\n  }\n\n  if (chartsBackground !== undefined && typeof chartsBackground !== 'string') {\n    throw new Error('chartsBackground must be a string if specified');\n  }\n\n  if (widthMode !== undefined && typeof widthMode !== 'string') {\n    throw new Error('widthMode must be a string if specified');\n  }\n\n  if (widthMode !== undefined && widthMode !== SCALING_ENUM.FIXED && widthMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`widthMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (heightMode !== undefined && typeof heightMode !== 'string') {\n    throw new Error('heightMode must be a string if specified');\n  }\n\n  if (heightMode !== undefined && heightMode !== SCALING_ENUM.FIXED && heightMode !== SCALING_ENUM.SCALE) {\n    throw new Error(`heightMode must be \"${SCALING_ENUM.FIXED}\" or \"${SCALING_ENUM.SCALE}\"`);\n  }\n\n  if (showTitleAndDesc !== undefined && typeof showTitleAndDesc !== 'boolean') {\n    throw new Error('showTitleAndDesc must be a boolean value if specified');\n  }\n\n  return { ...sharedEmbedOptions,\n    dashboardId,\n    chartsBackground,\n    widthMode,\n    heightMode,\n    showTitleAndDesc\n  };\n};\n\nclass DashboardEventSender extends BaseEmbedItem {\n  /** @ignore */\n  constructor(options) {\n    super();\n\n    _defineProperty$3(this, \"name\", 'Embedded Dashboard');\n\n    _defineProperty$3(this, \"ERRORS\", {\n      SEND: 'Dashboard has not been rendered. Ensure that you wait for the promise returned by `dashboard.render()` before trying to manipulate a dashboard.',\n      IFRAME: 'A dashboard can only be rendered into a container once'\n    });\n\n    _defineProperty$3(this, \"COLOUR\", {\n      LIGHT: '#F1F5F4',\n      DARK: '#12212C'\n    });\n\n    _defineProperty$3(this, \"options\", void 0);\n\n    this.options = getDashboardOptions(options);\n  }\n\n  getEmbedUrl() {\n    return getDashboardUrl(this.options);\n  }\n\n}\n/**\n * # Dashboard\n *\n * Allows you to interact and embed dashboards into your application.\n *\n * ```js\n * const sdk = new EmbedSDK({ ... });\n * const dashboard = sdk.createDashboard({ ... });\n *\n * // renders a dashboard\n * dashboard.render(document.getElementById('embed-dashboard'));\n *\n * ```\n */\n\n\nclass Dashboard extends Refreshable(DashboardEventSender) {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty$3(this, \"charts\", {});\n  }\n\n  /**\n   * @returns current chartsBackground or empty string if not set\n   */\n  async getChartsBackground() {\n    const [result] = await this._send('get', 'chartsBackground');\n    return typeof result === 'string' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set a custom background color for all charts.\n   * To clear existing value, set it to empty string.\n   */\n\n\n  async setChartsBackground(value) {\n    if (typeof value !== 'string') {\n      return Promise.reject('chartsBackground property value should be a string');\n    }\n\n    await this._send('set', 'chartsBackground', value);\n  }\n  /**\n   * @returns whether attribution logo should be shown\n   */\n\n\n  async isShowAttribution() {\n    const [result] = await this._send('get', 'attribution');\n    return typeof result === 'boolean' ? Boolean(result) : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Enable/Disable attribution logo.\n   */\n\n\n  async setShowAttribution(value) {\n    if (typeof value !== 'boolean') {\n      return Promise.reject('showAttribution property value should be a boolean');\n    }\n\n    await this._send('set', 'attribution', value);\n  }\n  /**\n   * @returns get width scaling mode of embedded dashboard\n   */\n\n\n  async getWidthMode() {\n    const [result] = await this._send('get', 'scalingWidth');\n    return result === SCALING_ENUM.FIXED || result === SCALING_ENUM.SCALE ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set width scaling mode for embedded dashboard\n   */\n\n\n  async setWidthMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('widthMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingWidth', value);\n  }\n  /**\n   * @returns get height scaling mode of embedded dashboard\n   */\n\n\n  async getHeightMode() {\n    const [result] = await this._send('get', 'scalingHeight');\n    return result === 'fixed' || result === 'scale' ? result : Promise.reject('unexpected response received from iframe');\n  }\n  /**\n   * Set height scaling mode for embedded dashboard\n   */\n\n\n  async setHeightMode(value) {\n    if (!['fixed', 'scale'].includes(value)) {\n      return Promise.reject('heightMode property value should be a string value of \"fixed\" or \"scale\"');\n    }\n\n    await this._send('set', 'scalingHeight', value);\n  }\n  /**\n   * @returns get the dashboard chart with specified id\n   */\n\n\n  async getChart(id) {\n    if (!this.charts[id]) {\n      const [chartIds] = await this._send('get', 'charts', [id]);\n\n      if (!Array.isArray(chartIds)) {\n        return Promise.reject('unexpected response received from iframe');\n      }\n\n      if (chartIds.length !== 1) {\n        return Promise.reject('Invalid chart id: ' + id);\n      }\n\n      this.charts[id] = new DashboardChart(id, this);\n    }\n\n    return this.charts[id];\n  }\n  /**\n   * @returns all charts on the dashboard\n   */\n\n\n  async getAllCharts() {\n    const [chartIds] = await this._send('get', 'charts');\n\n    if (!Array.isArray(chartIds)) {\n      return Promise.reject('unexpected response received from iframe');\n    }\n\n    const charts = [];\n    chartIds.forEach(id => {\n      if (!this.charts[id]) {\n        this.charts[id] = new DashboardChart(id, this);\n      }\n\n      charts.push(this.charts[id]);\n    });\n    return charts;\n  }\n\n  _configureHost(hostBuilder) {\n    return super._configureHost(hostBuilder).on('event', (event, payload, handlerIds) => {\n      const chartId = payload.chartId;\n\n      this.charts[chartId]._handleEvent(event, payload, handlerIds);\n    });\n  }\n\n}\n\n// Disabled temporarily to fix: https://github.com/mongodb-js/charts-embed-sdk/issues/14\n// Until we come up with a better way to have strong typing for the Stitch client, while\n// also not breaking normal TSC compiles of the SDK\n// import type { StitchAppClient } from 'mongodb-stitch-browser-sdk';\nconst isJWTExpired = jwt => {\n  try {\n    const [header, payload, signature] = jwt.split('.');\n    const {\n      exp\n    } = JSON.parse(atob(payload)); // Check the current time against the expiry (minus 5 minutes) in the token\n\n    return Date.now() / 1000 >= exp - 300;\n  } catch (e) {\n    throw new Error('Failed to parse Realm token. Is the StitchClient configured correctly?');\n  }\n};\n/**\n * A helper utility to support using [Realm Authentication](https://docs.mongodb.com/stitch/) with MongoDB Charts\n *\n * ```js\n * const client = Stitch.initializeDefaultAppClient('<your-client-app-id>');\n * client.auth.loginWithCredential(...)\n *\n * const sdk = new ChartsEmbedSDK({\n *   getUserToken: () => getRealmUserToken(client)\n * })\n * ```\n */\n\n\nasync function getRealmUserToken(stitchAppClient) {\n  const client = stitchAppClient;\n\n  if (!client.auth || !client.auth.authInfo) {\n    throw new Error('Unfamiliar Stitch client version');\n  }\n\n  if (!client.auth.isLoggedIn) {\n    throw new Error('Could not find a logged-in StitchUser. Is the StitchClient configured correctly?');\n  }\n\n  if (!client.auth.authInfo.accessToken) {\n    throw new Error('Could not find a valid JWT. Is the StitchClient configured correctly?');\n  }\n\n  if (isJWTExpired(client.auth.authInfo.accessToken)) {\n    // Attempt to refresh token using progression from public -> private apis\n    if (client.auth.refreshCustomData) {\n      await client.auth.refreshCustomData(); // supported from 4.8.0\n    } else if (client.auth.refreshAccessToken) {\n      await client.auth.refreshAccessToken(); // supported from 4.0.0\n    } else {\n      throw new Error('Could not refresh token. Unfamiliar Stitch client version');\n    }\n  }\n\n  return client.auth.authInfo.accessToken;\n}\n\nfunction _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * Creates an instance of the embedding SDK\n */\n\nclass EmbedSDK {\n  /**\n   * Accepts an optional {@link EmbedChartOptions} object to use as the\n   * default options for any charts created using this SDK instance.\n   *\n   * ```js\n   * const sdk = new EmbedSDK({\n   *   baseUrl: \"https://charts.mongodb.com\",\n   * })\n   * ```\n   */\n  constructor(options) {\n    _defineProperty$4(this, \"defaultOptions\", void 0);\n\n    this.defaultOptions = options;\n  }\n  /**\n   * Creates a new {@link Chart} instance that allows you to\n   * interact with and embed charts into your application\n   */\n\n\n  createChart(options) {\n    return new Chart({ ...this.defaultOptions,\n      ...options\n    });\n  }\n  /**\n   * Creates a new {@link Dashboard} instance that allows you\n   * to embed a dashboard into your application\n   */\n\n\n  createDashboard(options) {\n    return new Dashboard({ ...this.defaultOptions,\n      ...options\n    });\n  }\n\n}\n\nexport default EmbedSDK;\nexport { getRealmUserToken };\n"]},"metadata":{},"sourceType":"module"}